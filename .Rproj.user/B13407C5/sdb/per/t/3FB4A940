{
    "collab_server" : "",
    "contents" : "#' @title utils.R\n#' @export\n#' @description This is the R file containing all functions used for the genetic algorithm (GA)\n#' package.  An OOP approach was taken to complete this algorithm.\n\ninit <- function(df, P, c){\n  #' @title init (initialize)\n  #' @export\n  #' @description function outputs P random binary vectors of length c\n  #' @usage init(df, P, c)\n  #' @param df (data.frame): the datasets with X and Y.\n  #' @param P (int): number of candidates per generations\n  #' @param c (int): number of genes per chromosome candidate\n  #' @return generation(binary matrix P x c): P candidates\n  # outputs t P random binary vectors of length c\n  # input:\n  #   df (data.frame): the datasets with X and Y.\n  #   P (int): number of candidates per generations\n  # output:\n  #   generation(binary matrix P x c): P candidates\n  # c <- ncol(df) - 1\n  return(as.data.frame(matrix(c(rep(0,c),sample(c(0,1),(P-2)*c,replace = T),rep(1,c)), nrow = P, byrow = T)))\n\n  ## Notes.\n\n  # 1. make sure we have all 0 and all 1 in the initial generation.\n  # 2. what if weird number of P is entered? say very very small/large P.\n  #     - n\n  # return error.\n}\n\n\ntraining <- function(candidate, method_text, X, fitness_function_text, ...){\n  #' @title training\n  #' @export\n  #' @description This function fits the method on candidates and return the fitness value of the candidate\n  #' @usage training(candidate, method_text, X, fitness_function_text, ...)\n  #' @param candidate (binary vector length c): on or off for each columns of X\n  #' @param method: method for fitting lm/glm\n  #' @param X (matrix n x (c+1)): data (n x c) and the last column is the value of y.\n  #' @param fitness_function_text: type of function to evaluate fitness values\n  #' @return fitness_value (float): fitness value of the model\n  # fits the method on candidates and return the fitness value of the candidate\n  #   input:\n  #     candidate (binary vector length c): on or off for each columns of X\n  #     method: method for fitting lm/glm\n  #     X (matrix n x (c+1)): data (n x c) and the last column is the value of y.\n  #     fitness_function: error of the model\n  #   output:\n  #     fitness_value (float): fitness value of the model\n  method <- match.fun(method_text)\n  fitness_function <- match.fun(fitness_function_text)\n  individual_training <- function(x){\n    ynam <- colnames(X)[ncol(X)]\n    if (sum(x)==0){\n      fmla <- as.formula(paste(ynam, \" ~ 1\"))\n      return(fitness_function(method(fmla, data = X,...)))\n    }else{\n      xnam <- colnames(X)[which(as.logical(x))]\n      fmla <- as.formula(paste(ynam, \" ~ \", paste(xnam, collapse= \"+\")))\n      return(fitness_function(method(fmla, data = X,...)))\n    }\n  }\n  return(apply(candidate, 1, individual_training))\n}\n\nselect_parents <- function(fitness_values, mechanism, random = random, P, c){\n  #' @title select_parents\n  #' @export\n  #' @description This function returns pairs of parents for breeding\n  #' @usage select_parents(fitness_values, mechanism, random = random, P, c)\n  #' @param fitness_values (vector P): fitness_value of each of the candidate of the current generation\n  #' @param P (int): number of candidates per generation\n  #' @param mechanism: user defined rank-based selection mechanism,\n  #'         must be one of c(\"replace_all\",\"tournament\", \"partial_replace\")\n  #' @param random: A boolean value(T/F), \"T\" if choosing 1 parent selected proportional to fitness + 1 parent\n  #'         random selected and \"F\" if 2 parents selected proportional to to fitness\n  #' @param generation gap: proportion of the generation to be replaced by offspring\n  #'   output:\n  #' @return parents (matrix P x 2): each row is a pair of indices of parents\n  #' @return candidate(P x c): Each row is a candidate model for breeding\n  # returns P pairs of parents for breeding\n  #   input:\n  #     fitness_values (vector P): fitness_value of each of the candidate of the current generation\n  #     P (int): number of candidates per generation\n  #     mechanism: user defined rank-based selection mechanism,\n  #         must be one of c(\"replace_all\",\"tournament\", \"partial_replace\")\n  #     random: A boolean value(T/F), \"T\" if choosing 1 parent selected proportional to fitness + 1 parent\n  #         random selected and \"F\" if 2 parents selected proportional to to fitness\n  #     Gap: proportion of the generation to be replaced by offspring\n  #   output:\n  #     parents (matrix P x 2): each row is a pair of indices of parents\n  #     candidate(P x c): Each row is a candidate model for breeding\n\n  fitness_rank <- rank(-fitness_values)\n  fitness_phi <- fitness_rank/sum(fitness_rank)\n  parent.pairs <- matrix(rep(0,ceiling(P/2)*2), ncol = 2)\n  if (mechanism == \"rank\"){\n    i <- 0\n    if (random == TRUE){\n      while(i <= ceiling(P/2)){\n        parent.pairs[i,] <- c(sample.int(P, size = 1,prob = fitness_phi),\n                              sample.int(P, size = 1))\n        i <- i + 1\n      }\n    }else{\n      while(i <= ceiling(P/2)){\n        parent.pairs[i,] <- sample.int(P,size = 2,prob = fitness_phi)\n        i <- i + 1\n      }\n    }\n  }else if (mechanism == \"tournament\"){\n    tournament_sample <- NULL\n    for (i in 1:(2*ceiling(P/2))){\n      tournament_sample[i] <- which.max(fitness_rank[sample(1:P, size = max(5,ceiling(P/4)), replace = T)])\n    }\n    parent.pairs <- matrix(tournament_sample, byrow = T, ncol = 2)\n  }\n  return(parent.pairs)\n\n  # point:\n  # 1. after selection, the paired parents should be different.\n  # 2. avoid offsprings share the exact same gene.\n}\n\nbreed <- function(candidate, c, P, parent.pairs, mu, crossover_points, fitness_values, Gap){\n  #' @title breed\n  #' @export\n  #' @description This function returns P candidates of the next generation based on the pairs of parents.\n  #' Crossover and mutation is also contained within this function.\n  #' @usage breed(candidate, c, P, parent.pairs, mu, crossover_points, fitness_values, Gap)\n  #' @param candidate Each row of this matrix corresponds to a candidate model of current generation.\n  #' @param c The number of chromosomes for each candidate function.\n  #' @param parent.pairs Matrix of parent breeding pairs, a result of the \\emph{select_parents} function.\n  #' @param mu (float) This is the mutation rate of chromosomes in each candidate function\n  #' @param crossover_points Number of crossover points to be used in the bredding step.\n  #' @param fitness_values These are calculated fitness values of the present generation.\n  #' This comes in the form of a vector, and fitness values at a particular index corresponds\n  #' to the candidate function of the same index in the candidate function\n  #' @param Gap Generation gap for replacement of parents with offspring from each\n  #' created iteration of the GA\n  #' @return generation(binary matrix P x c): P candidates\n  # returns P candidates of the next generation based on the pairs of parents\n  #   input:\n  #     candidate: Each row is a candidate model for breeding\n  #     parents (matrix P x 2): each row is a pair of indices of parents\n  #     mu (float): mutation rate\n  #     crossover_points (int): number of crossover points\n  #   output:\n  #     generation(binary matrix P x c): P candidates\n  # crossover\n  # add if crossoverpoint = 0, skip crossover part.\n  crossover <- function(candidate, c, parent.pairs, crossover_points){\n    offspring <- as.data.frame(matrix(rep(0, nrow(parent.pairs)*2*c), ncol = c))\n    for (j in 1:nrow(parent.pairs)) {\n      temp1 <-  candidate[parent.pairs[j,1],]\n      temp2 <-  candidate[parent.pairs[j,2],]\n      pos <- c(0, sort(sample(1:(c-1), crossover_points, replace = F)), c)\n      pos_interval <- unname(split(1:c, rep(1:length(diff(pos)), diff(pos))))\n      change_idx <- (1:((crossover_points+1)/2))*2\n      for (i in 1:length(change_idx)){\n        temp <- temp1[pos_interval[[change_idx[i]]]]\n        temp1[pos_interval[[change_idx[i]]]] <- temp2[pos_interval[[change_idx[i]]]]\n        temp2[pos_interval[[change_idx[i]]]] <- temp\n      }\n      offspring[(2*j-1),] <- temp1\n      offspring[(2*j),] <- temp2\n    }\n    # notes: input 1 <= crossover_points <= c-1. else return error. warning(\"crossover_point not proper\")\n    #print(paste(\"Splitting occurs after position\", k))\n    # crossover points split the chromosome into parts,\n    # which we can express i-th part as chromosome[k_start[i], k[i]]\n    return(offspring)\n  }\n\n  #' @title mutation\n  #' @export\n  #' @usage mutation(offspring, mu)\n  #' @param offspring (data frame) contains the offspring produced from crossover\n  #' @param mu Mutation rate of the each allele within an offspring\n  #' @return offspring (data frame) Offspring data frame after mutation\n  # mutation\n  mutation <- function(offspring, mu){\n    for (i in 1: nrow(offspring)){\n      chromosome <-  offspring[i, ]\n      #generate associated uniform random variable for each locus\n      mutationLocus <-  runif(length(chromosome),0,1)\n      #mutation occurs if r.v. < mutationProbability\n      #find the location of mutation\n      mutationOccur <- (mutationLocus < mu)\n      #return the final result\n      offspring[i, ] <- (mutationOccur + chromosome) %% 2\n    }\n    return(offspring)\n  }\n\n  # Generation Gap\n  offspring <- mutation(crossover(candidate,c, parent.pairs, crossover_points), mu)\n  if (Gap == 1){\n    return(offspring) #return\n  }else{\n    num_replace= floor(P * Gap)\n    # assume each time P/2 mother and P/2 father produce P babies\n    # num_replace of parents will be replaced by random generated babies\n\n    # index of the replaced parents\n    replaced_index= sort(fitness_values, decreasing = T,index.return= TRUE)$ix[1:num_replace]\n    selected_babies= sample(nrow(offspring), size= num_replace, replace = FALSE)\n    candidate[replaced_index,] <- offspring[selected_babies,]\n    return(candidate) #return\n  }\n}\n\nget_model <- function(candidate, fitness_values, method_text, X, ...){\n  #' @title get_model\n  #' @export\n  #' @description This function returns the parameter of the model once we fit method on candidate\n  #' @usage get_model(candidate, fitness_values, method_text, X)\n  #' @param candidate (binary vector length c): on or off for each columns of X\n  #'     method: method for fitting\n  #' @param X (matrix n x (c+1)): data (n x c) and the last column is the value of y.\n  #' @return lm/glm object : the model selected after GA.\n  # returns the parameter of the model once we fit method on candidate\n  #   input:\n  #     candidate (binary vector length c): on or off for each columns of X\n  #     method: method for fitting\n  #     X (matrix n x (c+1)): data (n x c) and the last column is the value of y.\n  #   output:\n  #     lm/glm object : the model selected after GA.\n  method <- match.fun(method_text)\n\n  best <- candidate[which.min(fitness_values),]\n  ynam <- colnames(X)[ncol(X)]\n  if (sum(best)==0){\n    fmla <- as.formula(paste(ynam, \" ~ 1\"))\n    return(method(fmla, data = X,...))\n  }else{\n    xnam <- colnames(X)[which(as.logical(best))]\n    fmla <- as.formula(paste( ynam, \" ~ \", paste(xnam, collapse= \"+\")))\n    return(method(fmla, data = X,...))\n  }\n}\n",
    "created" : 1512949059356.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2392109362",
    "id" : "3FB4A940",
    "lastKnownWriteTime" : 1513164892,
    "last_content_update" : 1513164892031,
    "path" : "~/GA/R/utils.R",
    "project_path" : "R/utils.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}