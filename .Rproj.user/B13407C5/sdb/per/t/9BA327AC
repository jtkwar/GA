{
    "collab_server" : "",
    "contents" : "# This file calls the functions from utils to fit a model using genetic algorithm\n#source(\"./code/utils.R\")\n#library('ggplot2')\nsource(\"~/GA/R/utils.R\")\nsource(\"~/GA/R/input_variables.R\")\n\nselect <- function(df, P, max_iter, method_text, fitness_function_text, mu,\n                   crossover_points, mechanism , random = TRUE, Gap = 1/4, plot.return = FALSE){\n  #' @importFrom stats as.formula runif\n  #' @name select\n  #' @title{select()}\n  #' @export\n  #' @description This is main call function to run package GA.  This package is comprised of\n  #' a main execution file (\\emph{select.R} and a R file comtaining all functions\n  #' that are necessary for execution (\\emph{utils.R}).  The user can enter in a dataset and provide\n  #' variables (listed below) to execute the genetic algorithm.\n  #' @usage select(df, P, max_iter, method_text, fitness_function_text, mu,\n  #' crossover_points, mechanism, random = TRUE, Gap = 1/4, plot.return = FALSE)\n  #' @details Contained in the list below are the invdividual functions that are called during the\n  #' execution of the genetic algorithm.\n  #' \\itemize{\n  #'  \\item{init()}: {Initializes the dataframe for the dataset}\n  #'  \\item{training()}: {fits the method on candidates and return the fitness value of the candidate}\n  #'  \\item{select_parents()}: {Chooses parents for breeding based off of ranked\n  #'  or tournament selection using the fitness values of each parent}\n  #'  \\item{breed()}: {Breeds parents based off of pairing from select_parents()}\n  #'  \\item{crossover()}: {Function within breed() to conduct crossover between parent pairs\n  #'  during breeding step}\n  #'  \\item{mutation()}: {Determines if alleles of offspring (t+1 generation) mutates or not}\n  #'  \\item{get_model()}: {Returns the best fit model of the dataset}\n  #' }\n  #' @param df (data frame) Dataset to fit\n  #' @param P (int) The number of individuals per generation.\n  #' @param max_iter (int) The maximum number of iterations allowed when running GA\n  #' @param method_text lm() or glm() methods for fitting the data\n  #' @param fitness_function_text AIC, BIC, ow\n  #' @param mu: Mutation rate of the for each allele within the a given candidate chromosome.\n  #' @param crossover_points: (int) The number of crossover points during breeding step\n  #' @param mechanism: The mechanism to selection parents by.  Selection mechanisms\n  #' are \"ranked\" or \"tournament.\"\n  #' @param random (logical) Random replacement on or off for parent selection\n  #' @param Gap Generation gap that determines how parents (generation t) are replaced by offspring\n  #' of the (t+1) generation\n  #' @param plot.return (logical) Boolean for returning plot at end of the algorithm\n  c <- ncol(df) - 1\n  n <- nrow(df)\n  Xdata <- df[,1:c]\n  Y <- df[,c]\n  # note add warning on P. the range of P. P at least greater than 2.\n  candidate <- init(df = df, P = P, c = c)\n  iter <- 0\n  if (plot.return == FALSE){\n    min_fitness <- 0\n    while ((iter < max_iter) & (sum(min_fitness == min(min_fitness)) < 100)) {\n      candidate_fitness_value <- training(candidate = candidate, method_text = method_text,\n                                          X = df, fitness_function_text= fitness_function_text)\n      min_fitness[(iter+1)] <- min(candidate_fitness_value)\n      bn <- mean(min_fitness^2) - mean(min_fitness)^2\n      candidate_parents <- select_parents(fitness_values = candidate_fitness_value,\n                                          mechanism = mechanism, random = random, P = P, c = c)\n      candidate <- breed(candidate = candidate, c = c, P = P, parent.pairs = candidate_parents,\n                         mu = mu, crossover_points = crossover_points,\n                         fitness_values = candidate_fitness_value, Gap = Gap)\n      iter <- iter + 1\n    }\n    candidate_fitness_value <- training(candidate = candidate, method_text = method_text, X = df,\n                                        fitness_function_text= fitness_function_text)\n    best_model <- get_model(candidate = candidate, fitness_values = candidate_fitness_value,\n                            method_text = method_text, X = df)\n    return(list(count = iter, model = best_model))\n  }else{\n    plot_fitness_value <- NULL\n    min_fitness <- 0\n    while ((iter < max_iter) & (sum(min_fitness == min(min_fitness)) < 100)) {\n      candidate_fitness_value <- training(candidate = candidate, method_text = method_text,\n                                          X = df, fitness_function_text= fitness_function_text)\n      plot_fitness_value <- rbind(plot_fitness_value, cbind(rep((iter+1), P), -candidate_fitness_value))\n      min_fitness[(iter+1)] <- min(candidate_fitness_value)\n      bn <- mean(min_fitness^2) - mean(min_fitness)^2\n      candidate_parents <- select_parents(fitness_values = candidate_fitness_value,\n                                          mechanism = mechanism, random = random, P = P, c = c)\n      candidate <- breed(candidate = candidate, c = c, P = P, parent.pairs = candidate_parents,\n                         mu = mu, crossover_points = crossover_points,\n                         fitness_values = candidate_fitness_value, Gap = Gap)\n      iter <- iter + 1\n    }\n    plot_fitness_value <- as.data.frame(plot_fitness_value)\n    colnames(plot_fitness_value) <- c(\"generation\", \"fitness_value\")\n    p <- ggplot(plot_fitness_value, aes(generation, fitness_value)) +\n      geom_point() + labs(y = paste(\"Negative\", fitness_function_text), x = \"Generation\")\n    print(p)\n    candidate_fitness_value <- training(candidate = candidate, method_text = method_text,\n                                        X = df, fitness_function_text= fitness_function_text)\n    best_model <- get_model(candidate = candidate, fitness_values = candidate_fitness_value,\n                            method_text = method_text, X = df)\n    return(list(count = iter, model = best_model, plot = p))\n  }\n}\n",
    "created" : 1512949057813.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3028356383",
    "id" : "9BA327AC",
    "lastKnownWriteTime" : 1513164354,
    "last_content_update" : 1513164354952,
    "path" : "~/GA/R/select.R",
    "project_path" : "R/select.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}